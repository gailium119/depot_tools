{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "eed867fe_30a4fb87",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 3481761
      },
      "writtenOn": "2025-02-06T17:36:04Z",
      "side": 1,
      "message": "While working on implementing sokcevic@\u0027s suggestion about the name of the \"Directories\" field, I discovered that the uploading algorithm uses the list of directories to name the branches that it uploads, which seems like a fundamentally flawed approach due to nondeterminism. This should address that and also make future changes easier.",
      "revId": "577fc09899f65a52dbd14ceed4da9e8a4f3d928c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38db6456_50e6dc43",
        "filename": "split_cl.py",
        "patchSetId": 1
      },
      "lineNbr": 101,
      "author": {
        "id": 1560543
      },
      "writtenOn": "2025-02-06T21:10:43Z",
      "side": 1,
      "message": "`hash` returns a signed integer, and probably not the best to be used. It may also be hard to track it if someone runs split twice for whatever reason. Perhaps just using abs(hash(...)) will do the trick.\n\nOnce nice thing about the current implementation is that a user can assume what branch contains just be looking at its name. With a hash, that\u0027s not possible.\n\nSome other options: use incremental integer in a format \u0027{prefix}_split_{n}\u0027, or generate a unique name from files",
      "revId": "577fc09899f65a52dbd14ceed4da9e8a4f3d928c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc401fe9_5080039a",
        "filename": "split_cl.py",
        "patchSetId": 1
      },
      "lineNbr": 101,
      "author": {
        "id": 3481761
      },
      "writtenOn": "2025-02-06T21:44:57Z",
      "side": 1,
      "message": "\u003e It may also be hard to track it if someone runs split twice for whatever reason\n\nI\u0027m not sure what the concern here is, can you clarify? The hashes should be the same so long as the list of files is identical.\n\n\u003e ... abs(hash(...)) ...\n\nGood idea, will use this instead.\n\n\u003e Once nice thing about the current implementation is that a user can assume what branch contains just be looking at its name. With a hash, that\u0027s not possible.\n\nThis is definitely a downside, but I don\u0027t think it\u0027s very large, because the branches were already named semi-arbitrarily so you can\u0027t _really_ tell much just from the branch name.\n\n\u003e use incremental integer in a format \u0027{prefix}split{n}\u0027\n\nThe problem here is that you can\u0027t safely resume if they\u0027re named this way, since there isn\u0027t a relationship between the branch name and its contents (it also has the same downside as the hash of being unreadable to humans)\n\n\u003e generate a unique name from files\n\nThat\u0027s basically what I\u0027m doing with the hash, I just don\u0027t see a way to make it readable while preserving uniqueness and determinism of branch names.",
      "parentUuid": "38db6456_50e6dc43",
      "revId": "577fc09899f65a52dbd14ceed4da9e8a4f3d928c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a7cc7a2d_7412137e",
        "filename": "split_cl.py",
        "patchSetId": 1
      },
      "lineNbr": 101,
      "author": {
        "id": 1560543
      },
      "writtenOn": "2025-02-06T22:36:57Z",
      "side": 1,
      "message": "\u003e I\u0027m not sure what the concern here is, can you clarify? The hashes should be the same so long as the list of files is identical.\n\nI checked the entire codebase, and we don\u0027t create branches during --dry-run. With that, my concern is less valid. It is about what happens if someone runs git cl split multiple times on the same branch, they will end up with \nfoo_{hash1}\nfoo_{hash2}\nfoo_{hashN}\nand it will be hard to know which one contains what, and which one is obsolete. With the old implementation, at least user had an idea what each branch contains.\n\n\u003e The problem here is that you can\u0027t safely resume if they\u0027re named this way, since there isn\u0027t a relationship between the branch name and its contents \n\nThat\u0027s true. But I think we have a different problem if the split command is re-executed - let\u0027s assume someone modifies content of their mass change after split and re-runs it. Won\u0027t this potentially generate new branches, and leave old ones behind?\n\nI suggest we be more opinionated here. Perhaps, mandate that git cl split can only be executed once per branch, or user needs to clean old branches before git cl split can be executed again. Open to other suggestions - and that doesn\u0027t block this CL since it\u0027s not directly related to it.\n\n\u003e That\u0027s basically what I\u0027m doing with the hash, I just don\u0027t see a way to make it readable while preserving uniqueness and determinism of branch names.\n\nThis suggestion was to address my concern about know what branch contains what. This is very much optional. It could me something like: derive human-readable name based on the list of files, ensure there\u0027s no conflict (maybe by passing alrady used names).",
      "parentUuid": "bc401fe9_5080039a",
      "revId": "577fc09899f65a52dbd14ceed4da9e8a4f3d928c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e3d2cb8c_73445575",
        "filename": "split_cl.py",
        "patchSetId": 1
      },
      "lineNbr": 101,
      "author": {
        "id": 3481761
      },
      "writtenOn": "2025-02-06T23:43:54Z",
      "side": 1,
      "message": "\u003e I suggest we be more opinionated here. Perhaps, mandate that git cl split can only be executed once per branch, or user needs to clean old branches before git cl split can be executed again.\n\nThis makes sense to me for a future CL; I think the rule should probably be \"you must clean up old branches unless you\u0027re resuming a previous upload without any changes\". We can enforce this (in the current scheme) by computing the hashes for each branch we\u0027re going to generate in advance, and making sure there aren\u0027t any existing `_split` branches with a different hash. If there any any existing branches with the _same_ hash, we skip uploading them per the current resumption mechanism.\n\n\u003e Derive human-readable name based on the list of files, ensure there\u0027s no conflict (maybe by passing alrady used names).\n\nI suppose we could use some heuristic to infer a common directory (python has a function for this), and append that to the branch name after the hash. That should still be unique and deterministic, though it will get very long. The inferred directory might not be as useful as one a human would provide, but it\u0027s no worse than the current naming scheme.",
      "parentUuid": "a7cc7a2d_7412137e",
      "revId": "577fc09899f65a52dbd14ceed4da9e8a4f3d928c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}